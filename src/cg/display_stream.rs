use std::ffi::c_void;

use crate::{cf, cg, define_cf_type, dispatch, io, objc::blocks};

define_cf_type!(DisplayStream(cf::Type));
define_cf_type!(Update(cf::Type));

#[derive(Debug, Eq, PartialEq, Clone, Copy)]
#[repr(i32)]
pub enum UpdateRectType {
    /// The rectangles that were refreshed on the display, not counting moved rectangles
    RefreshedRects,

    /// The rectangles that were simply moved from one part of the display to another
    MovedRects,

    /// The union of both refreshed and moved rects
    DirtyRects,

    /// A possibly simplified (but overstated) array of dirty rectangles
    ReducedDirtyRects,
}

#[derive(Debug, Eq, PartialEq, Clone, Copy)]
#[repr(i32)]
pub enum FrameStatus {
    /// A new frame has been generated by the Window Server for a particular display at time displayTime
    FrameComplete,

    /// The Window Server did not generate a new frame for displayTime
    FrameIdle,

    /// As of displayTime, the display has gone blank
    FrameBlank,

    /// he display stream has stopped and no more calls will be made to the handler until the stream is started.
    StatusStopped,
}

impl Update {
    #[inline]
    pub fn type_id() -> cf::TypeId {
        unsafe { CGDisplayStreamUpdateGetTypeID() }
    }

    #[inline]
    pub fn merged(first: Option<&Self>, second: Option<&Self>) -> Option<cf::Retained<Self>> {
        unsafe { CGDisplayStreamUpdateCreateMergedUpdate(first, second) }
    }

    /// Returns a pointer to an array of CGRect structs that describe what parts of the frame have changed relative
    /// to the previously delivered frame.   This rectangle list encapsulates both the update rectangles and movement rectangles.
    pub unsafe fn get_rects(
        &self,
        rect_type: UpdateRectType,
        rect_count: *mut usize,
    ) -> *const cg::Rect {
        unsafe { CGDisplayStreamUpdateGetRects(self, rect_type, rect_count) }
    }

    pub unsafe fn moved_rect_delta(&self, x: *mut cg::Float, y: *mut cg::Float) {
        CGDisplayStreamUpdateGetMovedRectsDelta(self, x, y)
    }

    #[inline]
    pub fn drop_count(&self) -> usize {
        unsafe { CGDisplayStreamUpdateGetDropCount(self) }
    }
}

/// Provides a streaming API for capturing display updates in a realtime manner.  It can also provide
/// scaling and color space conversion services, as well as allow capturing sub regions of the display. Callbacks can be targetted
/// at either a traditional cf::RunLoop, or at a dispatch::queue.
impl DisplayStream {
    #[inline]
    pub fn type_id() -> cf::TypeId {
        unsafe { CGDisplayStreamGetTypeID() }
    }

    pub unsafe fn create(
        display: cg::DirectDisplayID,
        output_width: usize,
        output_height: usize,
        pixel_format: i32,
        properties: Option<&cf::Dictionary>,
        handler: *mut c_void,
    ) -> Option<cf::Retained<DisplayStream>> {
        unsafe {
            CGDisplayStreamCreate(
                display,
                output_width,
                output_height,
                pixel_format,
                properties,
                handler,
            )
        }
    }

    pub unsafe fn create_with_queue(
        display: cg::DirectDisplayID,
        output_width: usize,
        output_height: usize,
        pixel_format: i32,
        properties: Option<&cf::Dictionary>,
        queue: &dispatch::Queue,
        handler: *mut c_void,
    ) -> Option<cf::Retained<DisplayStream>> {
        unsafe {
            CGDisplayStreamCreateWithDispatchQueue(
                display,
                output_width,
                output_height,
                pixel_format,
                properties,
                queue,
                handler,
            )
        }
    }

    pub fn with_runloop<'ar, F>(
        display: cg::DirectDisplayID,
        output_width: usize,
        output_height: usize,
        pixel_format: i32,
        properties: Option<&cf::Dictionary>,
        handler: &mut blocks::Block<F>,
    ) -> Option<cf::Retained<DisplayStream>>
    where
        F: FnMut(FrameStatus, u64, Option<&'ar io::Surface>, Option<&'ar Update>),
    {
        unsafe {
            Self::create(
                display,
                output_width,
                output_height,
                pixel_format,
                properties,
                handler.as_ptr(),
            )
        }
    }

    pub fn with_dispatch_queue<'ar, F>(
        display: cg::DirectDisplayID,
        output_width: usize,
        output_height: usize,
        pixel_format: i32,
        properties: Option<&cf::Dictionary>,
        queue: &dispatch::Queue,
        handler: &mut blocks::Block<F>,
    ) -> Option<cf::Retained<DisplayStream>>
    where
        F: FnMut(FrameStatus, u64, Option<&'ar io::Surface>, Option<&'ar Update>),
    {
        unsafe {
            Self::create_with_queue(
                display,
                output_width,
                output_height,
                pixel_format,
                properties,
                queue,
                handler.as_ptr(),
            )
        }
    }

    #[inline]
    pub unsafe fn stream_start(&self) -> cg::Error {
        CGDisplayStreamStart(self)
    }

    pub fn start(&self) -> Result<(), cg::Error> {
        unsafe {
            match self.stream_start() {
                cg::Error::SUCCESS => Ok(()),
                e => Err(e),
            }
        }
    }

    #[inline]
    pub unsafe fn stream_stop(&self) -> cg::Error {
        CGDisplayStreamStop(self)
    }

    pub fn stop(&self) -> Result<(), cg::Error> {
        unsafe {
            match self.stream_stop() {
                cg::Error::SUCCESS => Ok(()),
                e => Err(e),
            }
        }
    }

    #[inline]
    pub fn run_loop_source(&self) -> Option<&cf::RunLoop> {
        unsafe { CGDisplayStreamGetRunLoopSource(self) }
    }
}

#[link(name = "CoreGraphics", kind = "framework")]
extern "C" {
    fn CGDisplayStreamUpdateGetTypeID() -> cf::TypeId;

    fn CGDisplayStreamUpdateGetRects(
        update_ref: &Update,
        rect_type: UpdateRectType,
        rect_count: *mut usize,
    ) -> *const cg::Rect;

    fn CGDisplayStreamUpdateCreateMergedUpdate(
        first: Option<&Update>,
        second: Option<&Update>,
    ) -> Option<cf::Retained<Update>>;

    fn CGDisplayStreamUpdateGetMovedRectsDelta(
        update_ref: &Update,
        x: *mut cg::Float,
        y: *mut cg::Float,
    );
    fn CGDisplayStreamUpdateGetDropCount(update_ref: &Update) -> usize;

    fn CGDisplayStreamGetTypeID() -> cf::TypeId;

    fn CGDisplayStreamCreate(
        display: cg::DirectDisplayID,
        output_width: usize,
        output_height: usize,
        pixel_format: i32,
        properties: Option<&cf::Dictionary>,
        handler: *mut c_void,
    ) -> Option<cf::Retained<DisplayStream>>;

    fn CGDisplayStreamCreateWithDispatchQueue(
        display: cg::DirectDisplayID,
        output_width: usize,
        output_height: usize,
        pixel_format: i32,
        properties: Option<&cf::Dictionary>,
        queue: &dispatch::Queue,
        handler: *mut c_void,
    ) -> Option<cf::Retained<DisplayStream>>;

    fn CGDisplayStreamStart(stream: &DisplayStream) -> cg::Error;
    fn CGDisplayStreamStop(stream: &DisplayStream) -> cg::Error;

    fn CGDisplayStreamGetRunLoopSource(stream: &DisplayStream) -> Option<&cf::RunLoop>;
}

#[cfg(test)]
mod tests {
    use std::{thread::sleep, time::Duration};


    #[test]
    fn basics() {
        use crate::{cf, cg, dispatch, objc::blocks};

        let mut block = blocks::mut4(|frame_status, b, c, d| {
            println!("got! {frame_status:?}")
        });

        let queue = dispatch::Queue::global(0).unwrap();

        let stream = cg::DisplayStream::with_dispatch_queue(
            cg::main_display_id(),
            640,
            480,
            i32::from_be_bytes(*b"420f"),
            None,
            queue,
            block.escape(),
        )
        .unwrap();

        stream.start().unwrap();

        sleep(Duration::from_secs(2));
    }
}
