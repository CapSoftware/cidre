// CF_ENUM(OSStatus)
// {
//     kAudio_UnimplementedError     = -4,
//     kAudio_FileNotFoundError      = -43,
//     kAudio_FilePermissionError    = -54,
//     kAudio_TooManyFilesOpenError  = -42,
//     kAudio_BadFilePathError       = '!pth', // 0x21707468, 561017960
//     kAudio_ParamError             = -50,
//     kAudio_MemFullError           = -108
// };

use std::ffi::c_void;

/// These are the error codes returned from the APIs found through Core Audio related frameworks.
pub mod os_status {
    use crate::os::Status;

    pub const UNIMPLEMENTED_ERROR: Status = Status(-4);
    pub const FILE_NOT_FOUND_ERROR: Status = Status(-43);
    pub const FILE_PERMISSION_ERROR: Status = Status(-54);
    pub const TOO_MANY_FILES_OPEN_ERROR: Status = Status(-42);
    pub const BAD_FILE_PATH_ERROR: Status = Status(i32::from_be_bytes(*b"!pth"));
    pub const PARAM_ERROR: Status = Status(-50);
    pub const MEM_FULL_ERROR: Status = Status(-108);
}

/// This structure holds a pair of numbers that represent a continuous range of values.
#[repr(C)]
pub struct AudioValueRange {
    pub minimum: f64,
    pub maximum: f64,
}

/// A structure to hold a buffer of audio data.
#[repr(C)]
pub struct AudioBuffer {
    /// The number of interleaved channels in the buffer.
    pub number_channels: u32,
    /// The number of bytes in the buffer pointed at by mData.
    pub data_bytes_syte: u32,
    /// A pointer to the buffer of audio data.
    pub data: *mut c_void,
}

#[repr(C)]
pub struct AudioBufferList {
    pub number_buffers: u32,
    /// this is a variable length array of mNumberBuffers elements
    pub buffers: *mut AudioBuffer,
}

/// A four char code indicating the general kind of data in the stream.
#[repr(transparent)]
pub struct AudioFormatID(pub u32);

/// The AudioFormatIDs used to identify individual formats of audio data.
impl AudioFormatID {
    /// Linear PCM, uses the standard flags.
    pub const LINEAR_PC: Self = Self(u32::from_be_bytes(*b"lpcm"));

    /// AC-3, has no flags.
    pub const AC3: Self = Self(u32::from_be_bytes(*b"ac-3"));

    /// AC-3 packaged for transport over an IEC 60958 compliant digital audio
    /// interface. Uses the standard flags.
    pub const _60958AC3: Self = Self(u32::from_be_bytes(*b"cac3"));

    /// Apples implementation of IMA 4:1 ADPCM, has no flags.
    pub const APPLE_IMA4: Self = Self(u32::from_be_bytes(*b"ima4"));

    /// MPEG-4 Low Complexity AAC audio object, has no flags.
    pub const MPEG4_AAC: Self = Self(u32::from_be_bytes(*b"aac "));

    /// MPEG-4 CELP audio object, has no flags.
    pub const MPEG4_CELP: Self = Self(u32::from_be_bytes(*b"celp"));

    /// MPEG-4 HVXC audio object, has no flags.
    pub const MPEG4_HVXC: Self = Self(u32::from_be_bytes(*b"hvxc"));

    /// MPEG-4 TwinVQ audio object type, has no flags.
    pub const MPEG4_TWIN_VQ: Self = Self(u32::from_be_bytes(*b"twvq"));

    /// MACE 3:1, has no flags.
    pub const MACE3: Self = Self(u32::from_be_bytes(*b"MAC3"));

    /// MACE 6:1, has no flags.
    pub const MACE6: Self = Self(u32::from_be_bytes(*b"MAC6"));

    /// ÂµLaw 2:1, has no flags.
    pub const U_LAW: Self = Self(u32::from_be_bytes(*b"ulaw"));

    /// aLaw 2:1, has no flags.
    pub const A_LAW: Self = Self(u32::from_be_bytes(*b"alaw"));

    /// QDesign music, has no flags
    pub const Q_DESIGN: Self = Self(u32::from_be_bytes(*b"QDMC"));

    /// QDesign2 music, has no flags
    pub const Q_DESIGN2: Self = Self(u32::from_be_bytes(*b"QDM2"));

    /// QUALCOMM PureVoice, has no flags
    pub const QUALCOMM: Self = Self(u32::from_be_bytes(*b"Qclp"));

    /// MPEG-1/2, Layer 1 audio, has no flags
    pub const MPEGLAYER1: Self = Self(u32::from_be_bytes(*b".mp1"));

    /// MPEG-1/2, Layer 2 audio, has no flags
    pub const MPEGLAYER2: Self = Self(u32::from_be_bytes(*b".mp2"));

    /// MPEG-1/2, Layer 3 audio, has no flags
    pub const MPEGLAYER3: Self = Self(u32::from_be_bytes(*b".mp3"));

    /// A stream of IOAudioTimeStamps, uses the IOAudioTimeStamp flags (see
    /// IOKit/audio/IOAudioTypes.h).
    pub const TIME_CODE: Self = Self(u32::from_be_bytes(*b"time"));

    /// A stream of MIDIPacketLists where the time stamps in the MIDIPacketList are
    /// sample offsets in the stream. The mSampleRate field is used to describe how
    /// time is passed in this kind of stream and an AudioUnit that receives or
    /// generates this stream can use this sample rate, the number of frames it is
    /// rendering and the sample offsets within the MIDIPacketList to define the
    /// time for any MIDI event within this list. It has no flags.
    pub const MIDI_STREAM: Self = Self(u32::from_be_bytes(*b"midi"));

    /// A "side-chain" of Float32 data that can be fed or generated by an AudioUnit
    /// and is used to send a high density of parameter value control information.
    /// An AU will typically run a ParameterValueStream at either the sample rate of
    /// the AudioUnit's audio data, or some integer divisor of this (say a half or a
    /// third of the sample rate of the audio). The Sample Rate of the ASBD
    /// describes this relationship. It has no flags.
    pub const PARAMETER_VALUE_STREAM: Self = Self(u32::from_be_bytes(*b"apvs"));

    /// Apple Lossless, the flags indicate the bit depth of the source material.
    pub const APPLE_LOSSLESS: Self = Self(u32::from_be_bytes(*b"alac"));

    /// MPEG-4 High Efficiency AAC audio object, has no flags.
    pub const MPEG4_AAC_HE: Self = Self(u32::from_be_bytes(*b"aach"));

    /// MPEG-4 AAC Low Delay audio object, has no flags.
    pub const MPEG4_AAC_LD: Self = Self(u32::from_be_bytes(*b"aacl"));

    /// MPEG-4 AAC Enhanced Low Delay audio object, has no flags. This is the formatID of
    /// the base layer without the SBR extension. See also kAudioFormatMPEG4AAC_ELD_SBR
    pub const MPEG4_AAC_ELD: Self = Self(u32::from_be_bytes(*b"aace"));

    /// MPEG-4 AAC Enhanced Low Delay audio object with SBR extension layer, has no flags.
    pub const MPEG4_AAC_ELD_SBR: Self = Self(u32::from_be_bytes(*b"aacf"));

    pub const MPEG4_AAC_ELD_V2: Self = Self(u32::from_be_bytes(*b"aacg"));

    /// MPEG-4 High Efficiency AAC Version 2 audio object, has no flags.    
    pub const MPEG4_AAC_HE_V2: Self = Self(u32::from_be_bytes(*b"aacp"));

    /// MPEG-4 Spatial Audio audio object, has no flags.
    pub const MPEG4_AAC_SPATIAL: Self = Self(u32::from_be_bytes(*b"aacs"));

    /// MPEG-D Unified Speech and Audio Coding, has no flags.
    pub const MPEG_D_USAC: Self = Self(u32::from_be_bytes(*b"usac"));

    /// The AMR Narrow Band speech codec.
    pub const AMR: Self = Self(u32::from_be_bytes(*b"samr"));

    /// The AMR Wide Band speech codec.
    pub const AMR_WB: Self = Self(u32::from_be_bytes(*b"sawb"));

    /// The format used for Audible audio books. It has no flags.
    pub const AUDIBLE: Self = Self(u32::from_be_bytes(*b"AUDB"));

    /// The iLBC narrow band speech codec. It has no flags.
    pub const LBC: Self = Self(u32::from_be_bytes(*b"ilbc"));

    /// DVI/Intel IMA ADPCM - ACM code 17.
    pub const DVI_INTEL_IMA: Self = Self(0x6D730011);

    /// Microsoft GSM 6.10 - ACM code 49.
    pub const MICROSOFT_GSM: Self = Self(0x6D730031);

    /// This format is defined by AES3-2003, and adopted into MXF and MPEG-2
    /// containers and SDTI transport streams with SMPTE specs 302M-2002 and
    /// 331M-2000. It has no flags.
    pub const AES3: Self = Self(u32::from_be_bytes(*b"aes3"));

    /// Enhanced AC-3, has no flags.
    pub const ENHANCED_AC3: Self = Self(u32::from_be_bytes(*b"ec-3"));

    /// Free Lossless Audio Codec, the flags indicate the bit depth of the source material.
    pub const FLAC: Self = Self(u32::from_be_bytes(*b"flac"));

    /// Opus codec, has no flags.
    pub const OPUS: Self = Self(u32::from_be_bytes(*b"opus"));
}

/// Flags that are specific to each format.
#[repr(transparent)]
pub struct AudioFormatFlags(pub u32);

/// These are the standard AudioFormatFlags for use in the mFormatFlags field of the
/// AudioStreamBasicDescription structure.
/// Typically, when an ASBD is being used, the fields describe the complete layout
/// of the sample data in the buffers that are represented by this description -
/// where typically those buffers are represented by an AudioBuffer that is
/// contained in an AudioBufferList.
///
/// However, when an ASBD has the kAudioFormatFlagIsNonInterleaved flag, the
/// AudioBufferList has a different structure and semantic. In this case, the ASBD
/// fields will describe the format of ONE of the AudioBuffers that are contained in
/// the list, AND each AudioBuffer in the list is determined to have a single (mono)
/// channel of audio data. Then, the ASBD's mChannelsPerFrame will indicate the
/// total number of AudioBuffers that are contained within the AudioBufferList -
/// where each buffer contains one channel. This is used primarily with the
/// AudioUnit (and AudioConverter) representation of this list - and won't be found
/// in the AudioHardware usage of this structure.
impl AudioFormatFlags {
    /// Set for floating point, clear for integer.
    pub const IS_FLOAT: Self = Self(1u32 << 0);

    /// Set for big endian, clear for little endian.
    pub const IS_BIG_ENDIAN: Self = Self(1u32 << 1);

    /// Set for signed integer, clear for unsigned integer. This is only valid if
    /// kAudioFormatFlagIsFloat is clear.
    pub const IS_SIGNED_INTEGER: Self = Self(1u32 << 2);

    /// Set if the sample bits occupy the entire available bits for the channel,
    /// clear if they are high or low aligned within the channel. Note that even if
    /// this flag is clear, it is implied that this flag is set if the
    /// AudioStreamBasicDescription is filled out such that the fields have the
    /// following relationship:
    ///     ((mBitsPerSample / 8) * mChannelsPerFrame) == mBytesPerFrame
    pub const IS_PACKED: Self = Self(1u32 << 3);

    /// Set if the sample bits are placed into the high bits of the channel, clear
    /// for low bit placement. This is only valid if kAudioFormatFlagIsPacked is
    /// clear.
    pub const IS_ALIGNED_HIGH: Self = Self(1u32 << 4);

    /// Set if the samples for each channel are located contiguously and the
    /// channels are layed out end to end, clear if the samples for each frame are
    /// layed out contiguously and the frames layed out end to end.
    pub const IS_NON_INTERLEAVED: Self = Self(1u32 << 5);

    /// Set to indicate when a format is non-mixable. Note that this flag is only
    /// used when interacting with the HAL's stream format information. It is not a
    /// valid flag for any other uses.
    pub const IS_NON_MIXABLE: Self = Self(1u32 << 6);

    /// Set if all the flags would be clear in order to preserve 0 as the wild card
    /// value.
    pub const ARE_ALL_CLEAR: Self = Self(0x80000000);

    pub const LINEAR_PCM_IS_FLOAT: Self = Self::IS_FLOAT;
    pub const LINEAR_PCM_IS_BIG_ENDIAN: Self = Self::IS_BIG_ENDIAN;
    pub const LINEAR_PCM_IS_SIGNED_INTEGER: Self = Self::IS_SIGNED_INTEGER;
    pub const LINEAR_PCM_IS_PACKED: Self = Self::IS_PACKED;
    pub const LINEAR_PCM_IS_ALIGNED_HIGH: Self = Self::IS_ALIGNED_HIGH;
    pub const LINEAR_PCM_IS_NON_INTERLEAVED: Self = Self::IS_NON_INTERLEAVED;
    pub const LINEAR_PCM_IS_NON_MIXABLE: Self = Self::IS_NON_MIXABLE;

    /// The linear PCM flags contain a 6-bit bitfield indicating that an integer
    /// format is to be interpreted as fixed point. The value indicates the number
    /// of bits are used to represent the fractional portion of each sample value.
    /// This constant indicates the bit position (counting from the right) of the
    /// bitfield in mFormatFlags.
    pub const LINEAR_PCM_SAMPLE_FRACTION_SHIFT: Self = Self(7);

    /// number_fractional_bits = (mFormatFlags &
    /// kLinearPCMFormatFlagsSampleFractionMask) >>
    /// kLinearPCMFormatFlagsSampleFractionShift
    pub const LINEAR_PCM_SAMPLE_FRACTION_MASK: Self =
        Self(0x3f << Self::LINEAR_PCM_SAMPLE_FRACTION_SHIFT.0);

    pub const LINEAR_PCM_ARE_ALL_CLEAR: Self = Self::ARE_ALL_CLEAR;

    /// This flag is set for Apple Lossless data that was sourced from 16 bit native
    /// endian signed integer data.
    pub const APPLE_LOSSLESS_16_BIT_SOURCE_DATA: Self = Self(1);

    /// This flag is set for Apple Lossless data that was sourced from 20 bit native
    /// endian signed integer data aligned high in 24 bits.
    pub const APPLE_LOSSLESS_20_BIT_SOURCE_DATA: Self = Self(2);

    /// his flag is set for Apple Lossless data that was sourced from 24 bit native
    /// endian signed integer data.
    pub const APPLE_LOSSLESS_24_BIT_SOURCE_DATA: Self = Self(3);

    /// This flag is set for Apple Lossless data that was sourced from 32 bit native
    /// endian signed integer data.
    pub const APPLE_LOSSLESS_32_BIT_SOURCE_DATA: Self = Self(4);
}

/// This structure encapsulates all the information for describing the basic
/// format properties of a stream of audio data.
///
/// This structure is sufficient to describe any constant bit rate format that  has
/// channels that are the same size. Extensions are required for variable bit rate
/// data and for constant bit rate data where the channels have unequal sizes.
/// However, where applicable, the appropriate fields will be filled out correctly
/// for these kinds of formats (the extra data is provided via separate properties).
/// In all fields, a value of 0 indicates that the field is either unknown, not
/// applicable or otherwise is inapproprate for the format and should be ignored.
/// Note that 0 is still a valid value for most formats in the mFormatFlags field.
///
/// In audio data a frame is one sample across all channels. In non-interleaved
/// audio, the per frame fields identify one channel. In interleaved audio, the per
/// frame fields identify the set of n channels. In uncompressed audio, a Packet is
/// one frame, (mFramesPerPacket == 1). In compressed audio, a Packet is an
/// indivisible chunk of compressed data, for example an AAC packet will contain
/// 1024 sample frames.
#[repr(C)]
pub struct AudioStreamBasicDescription {
    /// The number of sample frames per second of the data in the stream.
    pub sample_rate: f64,
    /// The AudioFormatID indicating the general kind of data in the stream.
    pub format_id: AudioFormatID,
    /// The AudioFormatFlags for the format indicated by mFormatID.
    pub format_flags: AudioFormatFlags,
    /// The number of bytes in a packet of data.
    pub bytes_per_packet: u32,
    /// The number of sample frames in each packet of data.
    pub frames_per_packet: u32,
    /// The number of bytes in a single sample frame of data.
    pub bytes_per_frame: u32,
    /// The number of channels in each frame of data.
    pub channels_per_frame: u32,
    /// The number of bits of sample data for each channel in a frame of data.
    pub bits_per_channel: u32,
    /// Pads the structure out to force an even 8 byte alignment.
    pub reserved: u32,
}

/// The format can use any sample rate. Note that this constant can only appear
/// in listings of supported formats. It will never appear in a current format.
pub const AUDIO_STREAM_ANY_RATE: f64 = 0.0;
